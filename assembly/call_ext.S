# THIS IS A FILE GENERATED BY meta_assembly_compile.py APPLIED ON call_ext_m.S
# ASSUME s1 holds a pointer to the pcb
# ASSUME s2 holds a pointer to argument pointer array for all instr
# ASSUME s3 holds a pointer to the argument array for this instr
# ASSUME s4 holds a pointer to the array of all callable cxx funs
# ASSUME s5 holds a pointer to the X register array 

# load index in table
ld t0, 8(s3) # generated from 'load_arg t0, 1'
slli t3, t0, 3
add t0, t0, s10

# CHANGE CODE POINTER HERE
# mv new code_chunk_p into a0 here! 
ld t0, 16(s4) # generated from 'call_cxx_fun SET_NEW_CODE_CHUNK'
jalr t0 # cont...
# check reductions - maybe yields
ld t0, 32(s1) # generated from 'load_shared t0, REDUCTIONS'
bnez t0, 1f

sd a4, 48(s1) # generated from 'store_shared a4, RESUME_LABEL'
li s8, 1# generated from 'exit_because YIELD'
jr s7# cont...
1:
addi t0, t0, -1
sd t0, 32(s1) # generated from 'store_shared t0, REDUCTIONS'

slli a2, a4, 3
add a2, a2, s6
ld t1, 0(a2)

la t0, 3f # load pc relative address at the end
sd t0, 40(s1) # generated from 'store_shared t0, CODE_POINTER'

jr t1

2: 
nop  # we will never reach here so we can store the code pointer here
nop  # 2 ops because 64 = 32 * 2
3:

la t0, 2b
ld a0, 0(t0)

# original code chunk pointer over here
ld t0, 16(s4) # generated from 'call_cxx_fun SET_NEW_CODE_CHUNK'
jalr t0 # cont...# RESTORE CODE POINTER HERE
