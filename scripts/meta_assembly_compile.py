import sys
import os
import re
from shared_variables import shared_variables

filename = sys.argv[1]
callable_fun_file = sys.argv[2]

assert (filename.endswith("_m.S"))
raw_asm_filename = filename[:-4] + ".S"


def get_tokens(line):
    tokens = list(map(lambda x: x.rstrip(", "), line.strip().split(" ")))
    return tokens


def transform_if_necessary(line: str):
    if line.startswith("load_shared"):
        tokens = get_tokens(line)

        assert (len(tokens) == 3)
        assert (tokens[0] == "load_shared")
        register = tokens[1]
        index = shared_variables[tokens[2]]

        # s1 is where we save the pointer to the shared variables
        # we initially pass it in as an argument then save it
        return f"ld {register}, {index * 8}(s1) " + \
            f"# generated from '{line.strip()}'\n"

    if line.startswith("store_shared"):
        tokens = get_tokens(line)

        assert (len(tokens) == 3)
        assert (tokens[0] == "store_shared")
        register = tokens[1]
        index = shared_variables[tokens[2]]

        # s1 is where we save the pointer to the shared variables
        # we initially pass it in as an argument then save it
        return f"sd {register}, {index * 8}(s1) " + \
            f"# generated from '{line.strip()}'\n"


    if line.startswith("load_arg"):
        tokens = get_tokens(line)

        assert (len(tokens) == 3)
        assert (tokens[0] == "load_arg")

        register = tokens[1]
        arg_index = int(tokens[2])

        # s3 is where we save the pointer to the argument array
        return f"ld {register}, {arg_index * 8}(s3) " + \
            f"# generated from '{line.strip()}'\n"

    if line.startswith("call_cxx_fun"):
        tokens = get_tokens(line)

        assert (len(tokens) == 2)
        assert (tokens[0] == "call_cxx_fun")

        fun_name = tokens[1].upper()
        fun_index = get_fun_index(fun_name)

        # check that we aren't giving a too large immediate
        # (12 bits signed max)
        assert (fun_index * 8 < 2048)

        # s4 is where we save the pointer to the function pointer array
        # we can use t0 since it is call-clobbered anyway
        instructions = (
            f"ld t0, {fun_index * 8}(s4) "
            f"# generated from '{line.strip()}'\n"
            f"jalr t0 "
            f"# cont..."
        )

        return instructions

    else:
        return line


def get_fun_index(fun_name):
    return get_fun_index.mapping[fun_name]


get_fun_index.mapping = {}
get_fun_index.count = 0
with open(callable_fun_file) as f:
    for line in f:
        match = re.search("// m_asm: (.*)", line)

        if match:
            fun_name = match.group(1).strip().upper()
            get_fun_index.mapping[fun_name] = get_fun_index.count
            get_fun_index.count += 1

disclaimer_lines = [
    f"# THIS IS A FILE GENERATED BY {os.path.basename(__file__)}" +
    f" APPLIED ON {filename}\n",
    "# ASSUME s1 holds a pointer to the pcb\n",
    "# ASSUME s2 holds a pointer to argument pointer array for all instr\n",
    "# ASSUME s3 holds a pointer to the argument array for this instr\n",
    "# ASSUME s4 holds a pointer to the array of all callable cxx funs\n\n",
]

with open(filename) as meta_asm_file:
    with open(raw_asm_filename, "w") as raw_asm_file:
        raw_asm_file.writelines(disclaimer_lines)

        for line in meta_asm_file:
            cleaned_line = line.strip(" ")
            raw_asm_file.write(transform_if_necessary(cleaned_line))
